/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../common";

export declare namespace Types {
  export type SignatureStruct = {
    v: PromiseOrValue<BigNumberish>;
    r: PromiseOrValue<BytesLike>;
    s: PromiseOrValue<BytesLike>;
  };

  export type SignatureStructOutput = [number, string, string] & {
    v: number;
    r: string;
    s: string;
  };

  export type IterationsStruct = {
    repay: PromiseOrValue<BigNumberish>;
    withdraw: PromiseOrValue<BigNumberish>;
  };

  export type IterationsStructOutput = [BigNumber, BigNumber] & {
    repay: BigNumber;
    withdraw: BigNumber;
  };

  export type LiquidityDataStruct = {
    borrowable: PromiseOrValue<BigNumberish>;
    maxDebt: PromiseOrValue<BigNumberish>;
    debt: PromiseOrValue<BigNumberish>;
  };

  export type LiquidityDataStructOutput = [BigNumber, BigNumber, BigNumber] & {
    borrowable: BigNumber;
    maxDebt: BigNumber;
    debt: BigNumber;
  };

  export type MarketSideIndexesStruct = {
    poolIndex: PromiseOrValue<BigNumberish>;
    p2pIndex: PromiseOrValue<BigNumberish>;
  };

  export type MarketSideIndexesStructOutput = [BigNumber, BigNumber] & {
    poolIndex: BigNumber;
    p2pIndex: BigNumber;
  };

  export type IndexesStruct = {
    supply: Types.MarketSideIndexesStruct;
    borrow: Types.MarketSideIndexesStruct;
  };

  export type IndexesStructOutput = [
    Types.MarketSideIndexesStructOutput,
    Types.MarketSideIndexesStructOutput
  ] & {
    supply: Types.MarketSideIndexesStructOutput;
    borrow: Types.MarketSideIndexesStructOutput;
  };

  export type MarketSideDeltaStruct = {
    scaledDelta: PromiseOrValue<BigNumberish>;
    scaledP2PTotal: PromiseOrValue<BigNumberish>;
  };

  export type MarketSideDeltaStructOutput = [BigNumber, BigNumber] & {
    scaledDelta: BigNumber;
    scaledP2PTotal: BigNumber;
  };

  export type DeltasStruct = {
    supply: Types.MarketSideDeltaStruct;
    borrow: Types.MarketSideDeltaStruct;
  };

  export type DeltasStructOutput = [
    Types.MarketSideDeltaStructOutput,
    Types.MarketSideDeltaStructOutput
  ] & {
    supply: Types.MarketSideDeltaStructOutput;
    borrow: Types.MarketSideDeltaStructOutput;
  };

  export type PauseStatusesStruct = {
    isP2PDisabled: PromiseOrValue<boolean>;
    isSupplyPaused: PromiseOrValue<boolean>;
    isSupplyCollateralPaused: PromiseOrValue<boolean>;
    isBorrowPaused: PromiseOrValue<boolean>;
    isWithdrawPaused: PromiseOrValue<boolean>;
    isWithdrawCollateralPaused: PromiseOrValue<boolean>;
    isRepayPaused: PromiseOrValue<boolean>;
    isLiquidateCollateralPaused: PromiseOrValue<boolean>;
    isLiquidateBorrowPaused: PromiseOrValue<boolean>;
    isDeprecated: PromiseOrValue<boolean>;
  };

  export type PauseStatusesStructOutput = [
    boolean,
    boolean,
    boolean,
    boolean,
    boolean,
    boolean,
    boolean,
    boolean,
    boolean,
    boolean
  ] & {
    isP2PDisabled: boolean;
    isSupplyPaused: boolean;
    isSupplyCollateralPaused: boolean;
    isBorrowPaused: boolean;
    isWithdrawPaused: boolean;
    isWithdrawCollateralPaused: boolean;
    isRepayPaused: boolean;
    isLiquidateCollateralPaused: boolean;
    isLiquidateBorrowPaused: boolean;
    isDeprecated: boolean;
  };

  export type MarketStruct = {
    indexes: Types.IndexesStruct;
    deltas: Types.DeltasStruct;
    underlying: PromiseOrValue<string>;
    pauseStatuses: Types.PauseStatusesStruct;
    isCollateral: PromiseOrValue<boolean>;
    variableDebtToken: PromiseOrValue<string>;
    lastUpdateTimestamp: PromiseOrValue<BigNumberish>;
    reserveFactor: PromiseOrValue<BigNumberish>;
    p2pIndexCursor: PromiseOrValue<BigNumberish>;
    aToken: PromiseOrValue<string>;
    stableDebtToken: PromiseOrValue<string>;
    idleSupply: PromiseOrValue<BigNumberish>;
  };

  export type MarketStructOutput = [
    Types.IndexesStructOutput,
    Types.DeltasStructOutput,
    string,
    Types.PauseStatusesStructOutput,
    boolean,
    string,
    number,
    number,
    number,
    string,
    string,
    BigNumber
  ] & {
    indexes: Types.IndexesStructOutput;
    deltas: Types.DeltasStructOutput;
    underlying: string;
    pauseStatuses: Types.PauseStatusesStructOutput;
    isCollateral: boolean;
    variableDebtToken: string;
    lastUpdateTimestamp: number;
    reserveFactor: number;
    p2pIndexCursor: number;
    aToken: string;
    stableDebtToken: string;
    idleSupply: BigNumber;
  };

  export type MarketSideIndexes256Struct = {
    poolIndex: PromiseOrValue<BigNumberish>;
    p2pIndex: PromiseOrValue<BigNumberish>;
  };

  export type MarketSideIndexes256StructOutput = [BigNumber, BigNumber] & {
    poolIndex: BigNumber;
    p2pIndex: BigNumber;
  };

  export type Indexes256Struct = {
    supply: Types.MarketSideIndexes256Struct;
    borrow: Types.MarketSideIndexes256Struct;
  };

  export type Indexes256StructOutput = [
    Types.MarketSideIndexes256StructOutput,
    Types.MarketSideIndexes256StructOutput
  ] & {
    supply: Types.MarketSideIndexes256StructOutput;
    borrow: Types.MarketSideIndexes256StructOutput;
  };
}

export interface MorphoAaveV3Interface extends utils.Interface {
  functions: {
    "DOMAIN_SEPARATOR()": FunctionFragment;
    "acceptOwnership()": FunctionFragment;
    "addressesProvider()": FunctionFragment;
    "approveManager(address,bool)": FunctionFragment;
    "approveManagerWithSig(address,address,bool,uint256,uint256,(uint8,bytes32,bytes32))": FunctionFragment;
    "borrow(address,uint256,address,address,uint256)": FunctionFragment;
    "borrowBalance(address,address)": FunctionFragment;
    "claimRewards(address[],address)": FunctionFragment;
    "claimToTreasury(address[],uint256[])": FunctionFragment;
    "collateralBalance(address,address)": FunctionFragment;
    "createMarket(address,uint16,uint16)": FunctionFragment;
    "defaultIterations()": FunctionFragment;
    "eModeCategoryId()": FunctionFragment;
    "getBucketsMask(address,uint8)": FunctionFragment;
    "getNext(address,uint8,address)": FunctionFragment;
    "increaseP2PDeltas(address,uint256)": FunctionFragment;
    "initialize(address,uint8,address,(uint128,uint128))": FunctionFragment;
    "isClaimRewardsPaused()": FunctionFragment;
    "isManaging(address,address)": FunctionFragment;
    "liquidate(address,address,address,uint256)": FunctionFragment;
    "liquidityData(address)": FunctionFragment;
    "market(address)": FunctionFragment;
    "marketsCreated()": FunctionFragment;
    "owner()": FunctionFragment;
    "pendingOwner()": FunctionFragment;
    "pool()": FunctionFragment;
    "positionsManager()": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "repay(address,uint256,address)": FunctionFragment;
    "repayWithPermit(address,uint256,address,uint256,(uint8,bytes32,bytes32))": FunctionFragment;
    "rewardsManager()": FunctionFragment;
    "scaledCollateralBalance(address,address)": FunctionFragment;
    "scaledP2PBorrowBalance(address,address)": FunctionFragment;
    "scaledP2PSupplyBalance(address,address)": FunctionFragment;
    "scaledPoolBorrowBalance(address,address)": FunctionFragment;
    "scaledPoolSupplyBalance(address,address)": FunctionFragment;
    "setAssetIsCollateral(address,bool)": FunctionFragment;
    "setAssetIsCollateralOnPool(address,bool)": FunctionFragment;
    "setDefaultIterations((uint128,uint128))": FunctionFragment;
    "setIsBorrowPaused(address,bool)": FunctionFragment;
    "setIsClaimRewardsPaused(bool)": FunctionFragment;
    "setIsDeprecated(address,bool)": FunctionFragment;
    "setIsLiquidateBorrowPaused(address,bool)": FunctionFragment;
    "setIsLiquidateCollateralPaused(address,bool)": FunctionFragment;
    "setIsP2PDisabled(address,bool)": FunctionFragment;
    "setIsPaused(address,bool)": FunctionFragment;
    "setIsPausedForAllMarkets(bool)": FunctionFragment;
    "setIsRepayPaused(address,bool)": FunctionFragment;
    "setIsSupplyCollateralPaused(address,bool)": FunctionFragment;
    "setIsSupplyPaused(address,bool)": FunctionFragment;
    "setIsWithdrawCollateralPaused(address,bool)": FunctionFragment;
    "setIsWithdrawPaused(address,bool)": FunctionFragment;
    "setP2PIndexCursor(address,uint16)": FunctionFragment;
    "setPositionsManager(address)": FunctionFragment;
    "setReserveFactor(address,uint16)": FunctionFragment;
    "setRewardsManager(address)": FunctionFragment;
    "setTreasuryVault(address)": FunctionFragment;
    "supply(address,uint256,address,uint256)": FunctionFragment;
    "supplyBalance(address,address)": FunctionFragment;
    "supplyCollateral(address,uint256,address)": FunctionFragment;
    "supplyCollateralWithPermit(address,uint256,address,uint256,(uint8,bytes32,bytes32))": FunctionFragment;
    "supplyWithPermit(address,uint256,address,uint256,uint256,(uint8,bytes32,bytes32))": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "treasuryVault()": FunctionFragment;
    "updatedIndexes(address)": FunctionFragment;
    "userBorrows(address)": FunctionFragment;
    "userCollaterals(address)": FunctionFragment;
    "userNonce(address)": FunctionFragment;
    "withdraw(address,uint256,address,address,uint256)": FunctionFragment;
    "withdrawCollateral(address,uint256,address,address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "DOMAIN_SEPARATOR"
      | "acceptOwnership"
      | "addressesProvider"
      | "approveManager"
      | "approveManagerWithSig"
      | "borrow"
      | "borrowBalance"
      | "claimRewards"
      | "claimToTreasury"
      | "collateralBalance"
      | "createMarket"
      | "defaultIterations"
      | "eModeCategoryId"
      | "getBucketsMask"
      | "getNext"
      | "increaseP2PDeltas"
      | "initialize"
      | "isClaimRewardsPaused"
      | "isManaging"
      | "liquidate"
      | "liquidityData"
      | "market"
      | "marketsCreated"
      | "owner"
      | "pendingOwner"
      | "pool"
      | "positionsManager"
      | "renounceOwnership"
      | "repay"
      | "repayWithPermit"
      | "rewardsManager"
      | "scaledCollateralBalance"
      | "scaledP2PBorrowBalance"
      | "scaledP2PSupplyBalance"
      | "scaledPoolBorrowBalance"
      | "scaledPoolSupplyBalance"
      | "setAssetIsCollateral"
      | "setAssetIsCollateralOnPool"
      | "setDefaultIterations"
      | "setIsBorrowPaused"
      | "setIsClaimRewardsPaused"
      | "setIsDeprecated"
      | "setIsLiquidateBorrowPaused"
      | "setIsLiquidateCollateralPaused"
      | "setIsP2PDisabled"
      | "setIsPaused"
      | "setIsPausedForAllMarkets"
      | "setIsRepayPaused"
      | "setIsSupplyCollateralPaused"
      | "setIsSupplyPaused"
      | "setIsWithdrawCollateralPaused"
      | "setIsWithdrawPaused"
      | "setP2PIndexCursor"
      | "setPositionsManager"
      | "setReserveFactor"
      | "setRewardsManager"
      | "setTreasuryVault"
      | "supply"
      | "supplyBalance"
      | "supplyCollateral"
      | "supplyCollateralWithPermit"
      | "supplyWithPermit"
      | "transferOwnership"
      | "treasuryVault"
      | "updatedIndexes"
      | "userBorrows"
      | "userCollaterals"
      | "userNonce"
      | "withdraw"
      | "withdrawCollateral"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "DOMAIN_SEPARATOR",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "acceptOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "addressesProvider",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "approveManager",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "approveManagerWithSig",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      Types.SignatureStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "borrow",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "borrowBalance",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "claimRewards",
    values: [PromiseOrValue<string>[], PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "claimToTreasury",
    values: [PromiseOrValue<string>[], PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "collateralBalance",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "createMarket",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "defaultIterations",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "eModeCategoryId",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getBucketsMask",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNext",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "increaseP2PDeltas",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      Types.IterationsStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "isClaimRewardsPaused",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isManaging",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidate",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "liquidityData",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "market",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "marketsCreated",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "pendingOwner",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "pool", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "positionsManager",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "repay",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "repayWithPermit",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      Types.SignatureStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "rewardsManager",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "scaledCollateralBalance",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "scaledP2PBorrowBalance",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "scaledP2PSupplyBalance",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "scaledPoolBorrowBalance",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "scaledPoolSupplyBalance",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setAssetIsCollateral",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setAssetIsCollateralOnPool",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setDefaultIterations",
    values: [Types.IterationsStruct]
  ): string;
  encodeFunctionData(
    functionFragment: "setIsBorrowPaused",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setIsClaimRewardsPaused",
    values: [PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setIsDeprecated",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setIsLiquidateBorrowPaused",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setIsLiquidateCollateralPaused",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setIsP2PDisabled",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setIsPaused",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setIsPausedForAllMarkets",
    values: [PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setIsRepayPaused",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setIsSupplyCollateralPaused",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setIsSupplyPaused",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setIsWithdrawCollateralPaused",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setIsWithdrawPaused",
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(
    functionFragment: "setP2PIndexCursor",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setPositionsManager",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setReserveFactor",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setRewardsManager",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setTreasuryVault",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "supply",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "supplyBalance",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "supplyCollateral",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "supplyCollateralWithPermit",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      Types.SignatureStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "supplyWithPermit",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      Types.SignatureStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "treasuryVault",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "updatedIndexes",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "userBorrows",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "userCollaterals",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "userNonce",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "withdraw",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawCollateral",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "DOMAIN_SEPARATOR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "acceptOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addressesProvider",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveManagerWithSig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "borrow", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "borrowBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimRewards",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimToTreasury",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "collateralBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createMarket",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "defaultIterations",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "eModeCategoryId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getBucketsMask",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getNext", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "increaseP2PDeltas",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isClaimRewardsPaused",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isManaging", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "liquidate", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "liquidityData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "market", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "marketsCreated",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "pendingOwner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "pool", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "positionsManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "repay", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "repayWithPermit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "rewardsManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "scaledCollateralBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "scaledP2PBorrowBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "scaledP2PSupplyBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "scaledPoolBorrowBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "scaledPoolSupplyBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAssetIsCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAssetIsCollateralOnPool",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setDefaultIterations",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setIsBorrowPaused",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setIsClaimRewardsPaused",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setIsDeprecated",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setIsLiquidateBorrowPaused",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setIsLiquidateCollateralPaused",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setIsP2PDisabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setIsPaused",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setIsPausedForAllMarkets",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setIsRepayPaused",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setIsSupplyCollateralPaused",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setIsSupplyPaused",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setIsWithdrawCollateralPaused",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setIsWithdrawPaused",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setP2PIndexCursor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPositionsManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setReserveFactor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setRewardsManager",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTreasuryVault",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "supply", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "supplyBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supplyCollateral",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supplyCollateralWithPermit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supplyWithPermit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "treasuryVault",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updatedIndexes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "userBorrows",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "userCollaterals",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "userNonce", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "withdraw", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdrawCollateral",
    data: BytesLike
  ): Result;

  events: {
    "Initialized(uint8)": EventFragment;
    "OwnershipTransferStarted(address,address)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferStarted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
}

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface OwnershipTransferStartedEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferStartedEvent = TypedEvent<
  [string, string],
  OwnershipTransferStartedEventObject
>;

export type OwnershipTransferStartedEventFilter =
  TypedEventFilter<OwnershipTransferStartedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface MorphoAaveV3 extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: MorphoAaveV3Interface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<[string]>;

    acceptOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    addressesProvider(overrides?: CallOverrides): Promise<[string]>;

    approveManager(
      manager: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    approveManagerWithSig(
      delegator: PromiseOrValue<string>,
      manager: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      nonce: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    borrow(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    borrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    claimRewards(
      assets: PromiseOrValue<string>[],
      onBehalf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    claimToTreasury(
      underlyings: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    collateralBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    createMarket(
      underlying: PromiseOrValue<string>,
      reserveFactor: PromiseOrValue<BigNumberish>,
      p2pIndexCursor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    defaultIterations(
      overrides?: CallOverrides
    ): Promise<[Types.IterationsStructOutput]>;

    eModeCategoryId(overrides?: CallOverrides): Promise<[BigNumber]>;

    getBucketsMask(
      underlying: PromiseOrValue<string>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getNext(
      underlying: PromiseOrValue<string>,
      position: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    increaseP2PDeltas(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    initialize(
      addressesProvider: PromiseOrValue<string>,
      eModeCategoryId: PromiseOrValue<BigNumberish>,
      positionsManager: PromiseOrValue<string>,
      defaultIterations: Types.IterationsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isClaimRewardsPaused(overrides?: CallOverrides): Promise<[boolean]>;

    isManaging(
      delegator: PromiseOrValue<string>,
      manager: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    liquidate(
      underlyingBorrowed: PromiseOrValue<string>,
      underlyingCollateral: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    liquidityData(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[Types.LiquidityDataStructOutput]>;

    market(
      underlying: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[Types.MarketStructOutput]>;

    marketsCreated(overrides?: CallOverrides): Promise<[string[]]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    pendingOwner(overrides?: CallOverrides): Promise<[string]>;

    pool(overrides?: CallOverrides): Promise<[string]>;

    positionsManager(overrides?: CallOverrides): Promise<[string]>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    repay(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    repayWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    rewardsManager(overrides?: CallOverrides): Promise<[string]>;

    scaledCollateralBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    scaledP2PBorrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    scaledP2PSupplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    scaledPoolBorrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    scaledPoolSupplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    setAssetIsCollateral(
      underlying: PromiseOrValue<string>,
      isCollateral: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setAssetIsCollateralOnPool(
      underlying: PromiseOrValue<string>,
      isCollateral: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setDefaultIterations(
      defaultIterations: Types.IterationsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setIsBorrowPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setIsClaimRewardsPaused(
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setIsDeprecated(
      underlying: PromiseOrValue<string>,
      isDeprecated: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setIsLiquidateBorrowPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setIsLiquidateCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setIsP2PDisabled(
      underlying: PromiseOrValue<string>,
      isP2PDisabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setIsPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setIsPausedForAllMarkets(
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setIsRepayPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setIsSupplyCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setIsSupplyPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setIsWithdrawCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setIsWithdrawPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setP2PIndexCursor(
      underlying: PromiseOrValue<string>,
      p2pIndexCursor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setPositionsManager(
      positionsManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setReserveFactor(
      underlying: PromiseOrValue<string>,
      newReserveFactor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setRewardsManager(
      rewardsManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setTreasuryVault(
      treasuryVault: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    supply(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    supplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    supplyCollateral(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    supplyCollateralWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    supplyWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    treasuryVault(overrides?: CallOverrides): Promise<[string]>;

    updatedIndexes(
      underlying: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [Types.Indexes256StructOutput] & { indexes: Types.Indexes256StructOutput }
    >;

    userBorrows(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    userCollaterals(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[string[]]>;

    userNonce(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    withdraw(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawCollateral(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

  acceptOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  addressesProvider(overrides?: CallOverrides): Promise<string>;

  approveManager(
    manager: PromiseOrValue<string>,
    isAllowed: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  approveManagerWithSig(
    delegator: PromiseOrValue<string>,
    manager: PromiseOrValue<string>,
    isAllowed: PromiseOrValue<boolean>,
    nonce: PromiseOrValue<BigNumberish>,
    deadline: PromiseOrValue<BigNumberish>,
    signature: Types.SignatureStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  borrow(
    underlying: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    onBehalf: PromiseOrValue<string>,
    receiver: PromiseOrValue<string>,
    maxIterations: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  borrowBalance(
    underlying: PromiseOrValue<string>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  claimRewards(
    assets: PromiseOrValue<string>[],
    onBehalf: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  claimToTreasury(
    underlyings: PromiseOrValue<string>[],
    amounts: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  collateralBalance(
    underlying: PromiseOrValue<string>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  createMarket(
    underlying: PromiseOrValue<string>,
    reserveFactor: PromiseOrValue<BigNumberish>,
    p2pIndexCursor: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  defaultIterations(
    overrides?: CallOverrides
  ): Promise<Types.IterationsStructOutput>;

  eModeCategoryId(overrides?: CallOverrides): Promise<BigNumber>;

  getBucketsMask(
    underlying: PromiseOrValue<string>,
    position: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getNext(
    underlying: PromiseOrValue<string>,
    position: PromiseOrValue<BigNumberish>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string>;

  increaseP2PDeltas(
    underlying: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  initialize(
    addressesProvider: PromiseOrValue<string>,
    eModeCategoryId: PromiseOrValue<BigNumberish>,
    positionsManager: PromiseOrValue<string>,
    defaultIterations: Types.IterationsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isClaimRewardsPaused(overrides?: CallOverrides): Promise<boolean>;

  isManaging(
    delegator: PromiseOrValue<string>,
    manager: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  liquidate(
    underlyingBorrowed: PromiseOrValue<string>,
    underlyingCollateral: PromiseOrValue<string>,
    user: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  liquidityData(
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<Types.LiquidityDataStructOutput>;

  market(
    underlying: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<Types.MarketStructOutput>;

  marketsCreated(overrides?: CallOverrides): Promise<string[]>;

  owner(overrides?: CallOverrides): Promise<string>;

  pendingOwner(overrides?: CallOverrides): Promise<string>;

  pool(overrides?: CallOverrides): Promise<string>;

  positionsManager(overrides?: CallOverrides): Promise<string>;

  renounceOwnership(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  repay(
    underlying: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    onBehalf: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  repayWithPermit(
    underlying: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    onBehalf: PromiseOrValue<string>,
    deadline: PromiseOrValue<BigNumberish>,
    signature: Types.SignatureStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  rewardsManager(overrides?: CallOverrides): Promise<string>;

  scaledCollateralBalance(
    underlying: PromiseOrValue<string>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  scaledP2PBorrowBalance(
    underlying: PromiseOrValue<string>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  scaledP2PSupplyBalance(
    underlying: PromiseOrValue<string>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  scaledPoolBorrowBalance(
    underlying: PromiseOrValue<string>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  scaledPoolSupplyBalance(
    underlying: PromiseOrValue<string>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  setAssetIsCollateral(
    underlying: PromiseOrValue<string>,
    isCollateral: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setAssetIsCollateralOnPool(
    underlying: PromiseOrValue<string>,
    isCollateral: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setDefaultIterations(
    defaultIterations: Types.IterationsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setIsBorrowPaused(
    underlying: PromiseOrValue<string>,
    isPaused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setIsClaimRewardsPaused(
    isPaused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setIsDeprecated(
    underlying: PromiseOrValue<string>,
    isDeprecated: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setIsLiquidateBorrowPaused(
    underlying: PromiseOrValue<string>,
    isPaused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setIsLiquidateCollateralPaused(
    underlying: PromiseOrValue<string>,
    isPaused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setIsP2PDisabled(
    underlying: PromiseOrValue<string>,
    isP2PDisabled: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setIsPaused(
    underlying: PromiseOrValue<string>,
    isPaused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setIsPausedForAllMarkets(
    isPaused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setIsRepayPaused(
    underlying: PromiseOrValue<string>,
    isPaused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setIsSupplyCollateralPaused(
    underlying: PromiseOrValue<string>,
    isPaused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setIsSupplyPaused(
    underlying: PromiseOrValue<string>,
    isPaused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setIsWithdrawCollateralPaused(
    underlying: PromiseOrValue<string>,
    isPaused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setIsWithdrawPaused(
    underlying: PromiseOrValue<string>,
    isPaused: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setP2PIndexCursor(
    underlying: PromiseOrValue<string>,
    p2pIndexCursor: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setPositionsManager(
    positionsManager: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setReserveFactor(
    underlying: PromiseOrValue<string>,
    newReserveFactor: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setRewardsManager(
    rewardsManager: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setTreasuryVault(
    treasuryVault: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  supply(
    underlying: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    onBehalf: PromiseOrValue<string>,
    maxIterations: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  supplyBalance(
    underlying: PromiseOrValue<string>,
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  supplyCollateral(
    underlying: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    onBehalf: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  supplyCollateralWithPermit(
    underlying: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    onBehalf: PromiseOrValue<string>,
    deadline: PromiseOrValue<BigNumberish>,
    signature: Types.SignatureStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  supplyWithPermit(
    underlying: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    onBehalf: PromiseOrValue<string>,
    maxIterations: PromiseOrValue<BigNumberish>,
    deadline: PromiseOrValue<BigNumberish>,
    signature: Types.SignatureStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  treasuryVault(overrides?: CallOverrides): Promise<string>;

  updatedIndexes(
    underlying: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<Types.Indexes256StructOutput>;

  userBorrows(
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string[]>;

  userCollaterals(
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<string[]>;

  userNonce(
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  withdraw(
    underlying: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    onBehalf: PromiseOrValue<string>,
    receiver: PromiseOrValue<string>,
    maxIterations: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawCollateral(
    underlying: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    onBehalf: PromiseOrValue<string>,
    receiver: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<string>;

    acceptOwnership(overrides?: CallOverrides): Promise<void>;

    addressesProvider(overrides?: CallOverrides): Promise<string>;

    approveManager(
      manager: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    approveManagerWithSig(
      delegator: PromiseOrValue<string>,
      manager: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      nonce: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    borrow(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    borrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimRewards(
      assets: PromiseOrValue<string>[],
      onBehalf: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [string[], BigNumber[]] & {
        rewardTokens: string[];
        claimedAmounts: BigNumber[];
      }
    >;

    claimToTreasury(
      underlyings: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    collateralBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    createMarket(
      underlying: PromiseOrValue<string>,
      reserveFactor: PromiseOrValue<BigNumberish>,
      p2pIndexCursor: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    defaultIterations(
      overrides?: CallOverrides
    ): Promise<Types.IterationsStructOutput>;

    eModeCategoryId(overrides?: CallOverrides): Promise<BigNumber>;

    getBucketsMask(
      underlying: PromiseOrValue<string>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNext(
      underlying: PromiseOrValue<string>,
      position: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>;

    increaseP2PDeltas(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    initialize(
      addressesProvider: PromiseOrValue<string>,
      eModeCategoryId: PromiseOrValue<BigNumberish>,
      positionsManager: PromiseOrValue<string>,
      defaultIterations: Types.IterationsStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    isClaimRewardsPaused(overrides?: CallOverrides): Promise<boolean>;

    isManaging(
      delegator: PromiseOrValue<string>,
      manager: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    liquidate(
      underlyingBorrowed: PromiseOrValue<string>,
      underlyingCollateral: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, BigNumber]>;

    liquidityData(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<Types.LiquidityDataStructOutput>;

    market(
      underlying: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<Types.MarketStructOutput>;

    marketsCreated(overrides?: CallOverrides): Promise<string[]>;

    owner(overrides?: CallOverrides): Promise<string>;

    pendingOwner(overrides?: CallOverrides): Promise<string>;

    pool(overrides?: CallOverrides): Promise<string>;

    positionsManager(overrides?: CallOverrides): Promise<string>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    repay(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    repayWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    rewardsManager(overrides?: CallOverrides): Promise<string>;

    scaledCollateralBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    scaledP2PBorrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    scaledP2PSupplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    scaledPoolBorrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    scaledPoolSupplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setAssetIsCollateral(
      underlying: PromiseOrValue<string>,
      isCollateral: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setAssetIsCollateralOnPool(
      underlying: PromiseOrValue<string>,
      isCollateral: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setDefaultIterations(
      defaultIterations: Types.IterationsStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    setIsBorrowPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setIsClaimRewardsPaused(
      isPaused: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setIsDeprecated(
      underlying: PromiseOrValue<string>,
      isDeprecated: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setIsLiquidateBorrowPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setIsLiquidateCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setIsP2PDisabled(
      underlying: PromiseOrValue<string>,
      isP2PDisabled: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setIsPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setIsPausedForAllMarkets(
      isPaused: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setIsRepayPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setIsSupplyCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setIsSupplyPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setIsWithdrawCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setIsWithdrawPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    setP2PIndexCursor(
      underlying: PromiseOrValue<string>,
      p2pIndexCursor: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setPositionsManager(
      positionsManager: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setReserveFactor(
      underlying: PromiseOrValue<string>,
      newReserveFactor: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setRewardsManager(
      rewardsManager: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setTreasuryVault(
      treasuryVault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    supply(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    supplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    supplyCollateral(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    supplyCollateralWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    supplyWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    treasuryVault(overrides?: CallOverrides): Promise<string>;

    updatedIndexes(
      underlying: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<Types.Indexes256StructOutput>;

    userBorrows(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string[]>;

    userCollaterals(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string[]>;

    userNonce(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    withdraw(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    withdrawCollateral(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {
    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "OwnershipTransferStarted(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferStartedEventFilter;
    OwnershipTransferStarted(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferStartedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter;
  };

  estimateGas: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<BigNumber>;

    acceptOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    addressesProvider(overrides?: CallOverrides): Promise<BigNumber>;

    approveManager(
      manager: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    approveManagerWithSig(
      delegator: PromiseOrValue<string>,
      manager: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      nonce: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    borrow(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    borrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    claimRewards(
      assets: PromiseOrValue<string>[],
      onBehalf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    claimToTreasury(
      underlyings: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    collateralBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    createMarket(
      underlying: PromiseOrValue<string>,
      reserveFactor: PromiseOrValue<BigNumberish>,
      p2pIndexCursor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    defaultIterations(overrides?: CallOverrides): Promise<BigNumber>;

    eModeCategoryId(overrides?: CallOverrides): Promise<BigNumber>;

    getBucketsMask(
      underlying: PromiseOrValue<string>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getNext(
      underlying: PromiseOrValue<string>,
      position: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    increaseP2PDeltas(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    initialize(
      addressesProvider: PromiseOrValue<string>,
      eModeCategoryId: PromiseOrValue<BigNumberish>,
      positionsManager: PromiseOrValue<string>,
      defaultIterations: Types.IterationsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isClaimRewardsPaused(overrides?: CallOverrides): Promise<BigNumber>;

    isManaging(
      delegator: PromiseOrValue<string>,
      manager: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    liquidate(
      underlyingBorrowed: PromiseOrValue<string>,
      underlyingCollateral: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    liquidityData(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    market(
      underlying: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    marketsCreated(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    pendingOwner(overrides?: CallOverrides): Promise<BigNumber>;

    pool(overrides?: CallOverrides): Promise<BigNumber>;

    positionsManager(overrides?: CallOverrides): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    repay(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    repayWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    rewardsManager(overrides?: CallOverrides): Promise<BigNumber>;

    scaledCollateralBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    scaledP2PBorrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    scaledP2PSupplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    scaledPoolBorrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    scaledPoolSupplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setAssetIsCollateral(
      underlying: PromiseOrValue<string>,
      isCollateral: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setAssetIsCollateralOnPool(
      underlying: PromiseOrValue<string>,
      isCollateral: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setDefaultIterations(
      defaultIterations: Types.IterationsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setIsBorrowPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setIsClaimRewardsPaused(
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setIsDeprecated(
      underlying: PromiseOrValue<string>,
      isDeprecated: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setIsLiquidateBorrowPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setIsLiquidateCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setIsP2PDisabled(
      underlying: PromiseOrValue<string>,
      isP2PDisabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setIsPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setIsPausedForAllMarkets(
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setIsRepayPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setIsSupplyCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setIsSupplyPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setIsWithdrawCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setIsWithdrawPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setP2PIndexCursor(
      underlying: PromiseOrValue<string>,
      p2pIndexCursor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setPositionsManager(
      positionsManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setReserveFactor(
      underlying: PromiseOrValue<string>,
      newReserveFactor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setRewardsManager(
      rewardsManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setTreasuryVault(
      treasuryVault: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    supply(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    supplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    supplyCollateral(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    supplyCollateralWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    supplyWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    treasuryVault(overrides?: CallOverrides): Promise<BigNumber>;

    updatedIndexes(
      underlying: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    userBorrows(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    userCollaterals(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    userNonce(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    withdraw(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawCollateral(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    DOMAIN_SEPARATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    acceptOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    addressesProvider(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    approveManager(
      manager: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    approveManagerWithSig(
      delegator: PromiseOrValue<string>,
      manager: PromiseOrValue<string>,
      isAllowed: PromiseOrValue<boolean>,
      nonce: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    borrow(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    borrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    claimRewards(
      assets: PromiseOrValue<string>[],
      onBehalf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    claimToTreasury(
      underlyings: PromiseOrValue<string>[],
      amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    collateralBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    createMarket(
      underlying: PromiseOrValue<string>,
      reserveFactor: PromiseOrValue<BigNumberish>,
      p2pIndexCursor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    defaultIterations(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    eModeCategoryId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getBucketsMask(
      underlying: PromiseOrValue<string>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getNext(
      underlying: PromiseOrValue<string>,
      position: PromiseOrValue<BigNumberish>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    increaseP2PDeltas(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    initialize(
      addressesProvider: PromiseOrValue<string>,
      eModeCategoryId: PromiseOrValue<BigNumberish>,
      positionsManager: PromiseOrValue<string>,
      defaultIterations: Types.IterationsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isClaimRewardsPaused(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    isManaging(
      delegator: PromiseOrValue<string>,
      manager: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    liquidate(
      underlyingBorrowed: PromiseOrValue<string>,
      underlyingCollateral: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    liquidityData(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    market(
      underlying: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    marketsCreated(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingOwner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pool(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    positionsManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    repay(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    repayWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    rewardsManager(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    scaledCollateralBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    scaledP2PBorrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    scaledP2PSupplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    scaledPoolBorrowBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    scaledPoolSupplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setAssetIsCollateral(
      underlying: PromiseOrValue<string>,
      isCollateral: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setAssetIsCollateralOnPool(
      underlying: PromiseOrValue<string>,
      isCollateral: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setDefaultIterations(
      defaultIterations: Types.IterationsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setIsBorrowPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setIsClaimRewardsPaused(
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setIsDeprecated(
      underlying: PromiseOrValue<string>,
      isDeprecated: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setIsLiquidateBorrowPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setIsLiquidateCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setIsP2PDisabled(
      underlying: PromiseOrValue<string>,
      isP2PDisabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setIsPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setIsPausedForAllMarkets(
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setIsRepayPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setIsSupplyCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setIsSupplyPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setIsWithdrawCollateralPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setIsWithdrawPaused(
      underlying: PromiseOrValue<string>,
      isPaused: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setP2PIndexCursor(
      underlying: PromiseOrValue<string>,
      p2pIndexCursor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setPositionsManager(
      positionsManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setReserveFactor(
      underlying: PromiseOrValue<string>,
      newReserveFactor: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setRewardsManager(
      rewardsManager: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setTreasuryVault(
      treasuryVault: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    supply(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    supplyBalance(
      underlying: PromiseOrValue<string>,
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    supplyCollateral(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    supplyCollateralWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    supplyWithPermit(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      deadline: PromiseOrValue<BigNumberish>,
      signature: Types.SignatureStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    treasuryVault(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    updatedIndexes(
      underlying: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    userBorrows(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    userCollaterals(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    userNonce(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    withdraw(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      maxIterations: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawCollateral(
      underlying: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      onBehalf: PromiseOrValue<string>,
      receiver: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
